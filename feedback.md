# Assignment One Feedback
## Tutor Comment
Great job!

I can see that you have put in effort to avoid excessively long switch and if-else statements, making your code more compact and readable. Just be careful that you don't make it too compact that it is hard to understand what is going on :) A greater use of comments can also help make your code more readable for you and anyone else reading or working on your code - this will be especially helpful in your group assignment.

You have made good, regular use of git, however your commit messages could be a little more specific as to what has been changed since the last commit.

For future assignments, it can make it easier to keep track of what still needs to be done if you remove fixme comments after you have completed a task. Keep this in mind when working on your group assignment :)
## Mark

**  4.5/5.0**

## Miscellaneous marks

| Level | Requirement | Result |
|:-:|---|:-:|
|P|Forked assignment 1 repository | 0.5/0.5 |
|P|Originality statement edited, committed, pushed | 0.5/0.5 |
|P|Git log file reveals healthy use of Git | 0.25/0.25 |
|P|Edited classes compile correctly | 0.25/0.25 |
|CR|Code is of high quality | 0.5/0.5 |
|HD|Solution is outstanding in its design and implementation | 0.25/0.5 |

**Total for miscellaneous marks:** 2.25/2.5

## Test results
```
Test Name   Tests Passed  Weighting     Score
-----              -----      -----     -----
task1                4/4        0.1       0.1
task2                9/9        0.3       0.3
task3                3/3        0.2       0.2
task4                3/3        0.1       0.1
task5                5/5        0.1       0.1
task6                3/3        0.2       0.2
task7                3/3        0.1       0.1
task8                2/2        0.2       0.2
task9                3/3        0.2       0.2
task10               4/4       0.25      0.25
task11               5/5       0.25      0.25
task12               4/4       0.25      0.25
task13               0/3       0.25       0.0
-----              -----     Total:  2.25/2.5
```
## Originality statement
# IMPORTANT: It is very important that you correctly complete this originality
# statement.
#
# This is your statement of your submitted work being your own.
# Incorrectly filling out this statement could lead to charges
# of academic misconduct.
# 
# For information on how to fill this out correctly, see
# https://cs.anu.edu.au/courses/comp1110/help/faq/09-originality/
#

declaration: >-
  I declare that everything I have submitted in this assignment is entirely my
  own work, with the following exceptions:


# Use this to list names of people who you collaborated with, and a
# comment about what you collaborated on.
#
# Add as many "name+comment" entries as necessary
# (or remove it altogether if you haven't collaborated with anyone)


# Use this to list any code that you used that you did not write,
# aside from code provided by the lecturer.  Provide a comment
# explaining your use and the URL to that code and the licence for
# that code
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external code)


# Use this to list any assets (artwork, sound, etc) that you used.
# Provide a comment explaining your use of that asset and the URL
# and license for the asset
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external assets)



# sign *your* name and uid here
name: MingLei
uid: u7172618
## Git Log
```
commit ba831a7817b9b2b491286400bbc2f60b3468dd46
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Mon Aug 10 23:30:26 2020 -0700

    complete task 1-12

commit 32b828dc0790a5fe59a62cc93b96ed91e87a4483
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 01:05:55 2020 -0700

    complete task

commit 4d507245687f08d984b4b1e92783e2719ece8aad
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:30:13 2020 -0700

    complete task

commit c58e0e274cf015c194b8e5b60c0b5faf212bfbc2
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:29:26 2020 -0700

    complete task

commit 0a3302292273a12581ae4b75ccc9991c002d3f61
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:26:36 2020 -0700

    Completed tasks

commit bc63ce8eafd55308e1fdb3f8bf67da7939954c9c
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:16:10 2020 -0700

    Completed tasks

commit 24d1880adad4b524497f58d6ea2e393311789950
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:13:08 2020 -0700

    Completed tasks

commit 11012a7b6be4784f8f181c2778e34227d52b34bf
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:10:51 2020 -0700

    Completed tasks

commit b6db19ef8f10673364a34c0befe67d9f9143f3d1
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Sat Aug 8 00:07:06 2020 -0700

    Completed tasks

commit cc16c57dd0420b3e33941eddb9578b9eab8f402c
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Fri Aug 7 23:52:44 2020 -0700

    Completed task 1

commit a3e2ae9113c1445179fbbfed6540f7448991f658
Merge: 7e3b57a 9e4916a
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Fri Aug 7 23:46:20 2020 -0700

    Merge remote-tracking branch 'origin/master'

commit 7e3b57aa096c3a47b521410c9848a1201e439e83
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Fri Aug 7 23:45:14 2020 -0700

    Completed task 1 to 12

commit 9e4916a32116ab1b2863a3f230e18c9866e38f46
Author: Ming Lei <ming.lei@anu.edu.au>
Date:   Sat Aug 8 16:42:14 2020 +1000

    Update originality.yml

commit e73e5da7d71ef07a531d5dce673eafffe1aae7b4
Merge: 2a7dfcd e81b77a
Author: u7172618 <ming.lei@anu.edu.au>
Date:   Fri Aug 7 23:40:16 2020 -0700

    Merge remote-tracking branch 'origin/master'

commit e81b77a87e3d759961931f496e7d161a0ccea5a2
Author: Ming Lei <ming.lei@anu.edu.au>
Date:   Sat Aug 8 16:31:31 2020 +1000

    My originality declaration.

commit 2a7dfcd52d995a8710f46bee9fc9b60a49727aab
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Mon Aug 3 19:50:41 2020 +1000

    Fixed GUI bug

commit 141fbc6b65495285212c6818763957ecc7a149a8
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 23:16:02 2020 +1000

    Correction to additional test case

commit 5b43f286279d899a6aa92f2f568a3f12e93f668d
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 21:57:44 2020 +1000

    Additional test case

commit 8aa7d205a93cb3df086ba15f2f7309871f272abc
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 31 09:41:18 2020 +1000

    Fix problem of null tiles leading to NPEs in some situations

commit df6cc12357ee8ce98f0f605dbcd3b859f2410f03
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 20:07:18 2020 +1000

    Correction and clarification

commit ea45758dca7883f625aff63cc8b8986f487ddb82
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 19:58:20 2020 +1000

    Allow GUI to work even with incomplete tasks

commit 1518efe703e6e3f81c518743adf515e213530139
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 29 17:19:40 2020 +1000

    Initial import
```
## Changes
``` diff
Only in comp1110-ass1: feedback.md
diff -ru -x .git /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/originality.yml comp1110-ass1/originality.yml
--- /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/originality.yml	2020-08-18 19:17:24.000000000 +1000
+++ comp1110-ass1/originality.yml	2020-08-18 19:35:48.000000000 +1000
@@ -19,9 +19,7 @@
 #
 # Add as many "name+comment" entries as necessary
 # (or remove it altogether if you haven't collaborated with anyone)
-collaboration:
-  - name:
-    comment: >-
+
 
 # Use this to list any code that you used that you did not write,
 # aside from code provided by the lecturer.  Provide a comment
@@ -30,10 +28,7 @@
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external code)
-code:
-  - comment:
-    url:
-    licence:
+
 
 # Use this to list any assets (artwork, sound, etc) that you used.
 # Provide a comment explaining your use of that asset and the URL
@@ -41,12 +36,9 @@
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external assets)
-assets:
-  - comment:
-    url:
-    licence:
+
 
 
 # sign *your* name and uid here
-name:
-uid:
+name: MingLei
+uid: u7172618
diff -ru -x .git /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Direction.java comp1110-ass1/src/comp1110/ass1/Direction.java
--- /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Direction.java	2020-08-18 19:17:24.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Direction.java	2020-08-18 19:35:48.000000000 +1000
@@ -30,7 +30,14 @@
      * @return the `Direction` associated with the char.
      */
     public static Direction fromChar(char direction) {
-        return NORTH; // FIXME Task 2.a (P)
+        // FIXME Task 2.a (P)
+        if (!"N".equals(String.valueOf(direction))) {
+            if ("E".equals(String.valueOf(direction))) {return EAST;}
+            else if ("S".equals(String.valueOf(direction))) {return SOUTH;}
+            else return WEST;
+        } else {
+            return NORTH;
+        }
     }
 
     /**
@@ -41,7 +48,7 @@
      * @return The first character of the name of the direction
      */
     public char toChar() {
-        return ' ';  // FIXME Task 2.b (P)
+        return this.name().charAt(0);  // FIXME Task 2.b (P)
     }
 
     /**
@@ -50,7 +57,16 @@
      * for example: the opposite Direction of 'NORTH' would be 'SOUTH'.
      */
     public Direction getOpposite() {
-       return null; // FIXME Task 3 (P)
+        switch (this) {
+            case NORTH:
+                return SOUTH;
+            case SOUTH:
+                return NORTH;
+            case EAST:
+                return WEST;
+            default:
+                return EAST;
+        }// FIXME Task 3 (P)
     }
 
     /** @return this direction's symbol as a string */
diff -ru -x .git /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java comp1110-ass1/src/comp1110/ass1/Objective.java
--- /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java	2020-08-18 19:17:24.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Objective.java	2020-08-18 19:35:48.000000000 +1000
@@ -154,9 +154,20 @@
      */
     public static Objective newObjective(int difficulty) {
         assert difficulty >= 0 && difficulty <= 4;
-        return OBJECTIVES[0]; // FIXME Task 5 (P)
+        int diffrange0 =(int) (Math.random()*(12-1))+1;
+        int diffrange1 =(int) (Math.random()*(24-13))+13;
+        int diffrange2 =(int) (Math.random()*(36-25))+25;
+        int diffrange3 =(int) (Math.random()*(48-37))+37;
+        int diffrange4 =(int) (Math.random()*(60-49))+49;
+        switch (difficulty){
+            case(0):return OBJECTIVES[diffrange0];
+            case(1):return OBJECTIVES[diffrange1];
+            case(2):return OBJECTIVES[diffrange2];
+            case(3):return OBJECTIVES[diffrange3];
+            default:return OBJECTIVES[diffrange4];
+        }
     }
-
+    // FIXME Task 5
     public String getInitialState() {
         return initialState;
     }
diff -ru -x .git /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/TempleTrap.java comp1110-ass1/src/comp1110/ass1/TempleTrap.java
--- /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/TempleTrap.java	2020-08-18 19:17:24.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/TempleTrap.java	2020-08-18 19:35:48.000000000 +1000
@@ -24,7 +24,7 @@
      * the array will store the tile that is currently at each of the
      * nine board positions, with a null representing the position which
      * has no tile.
-     *
+     * <p>
      * If a Tile is in position 0, then board[0] holds a reference to that
      * Tile instance.  If a Tile is in position 3, then board[3] holds a
      * reference to that Tile instance. If the position is empty, that
@@ -32,7 +32,9 @@
      */
     public Tile[] board = new Tile[9];
 
-    /** The board position holding the peg */
+    /**
+     * The board position holding the peg
+     */
     private int pegPosition;
 
     /**
@@ -56,14 +58,27 @@
         this(Objective.newObjective(difficulty));
     }
 
-    /** @return The Objective for the current TempleTrap instance. */
-    public Objective getObjective() {  return objective; }
+    /**
+     * @return The Objective for the current TempleTrap instance.
+     */
+    public Objective getObjective() {
+        return objective;
+    }
 
-    /** @return the current peg position for this game */
-    public int getPegPosition() { return pegPosition; }
+    /**
+     * @return the current peg position for this game
+     */
+    public int getPegPosition() {
+        return pegPosition;
+    }
+
+    /**
+     * @param position The new peg position
+     */
+    public void setPegPosition(int position) {
+        pegPosition = position;
+    }
 
-    /** @param position The new peg position  */
-    public void setPegPosition(int position) {  pegPosition = position; }
     /**
      * Initialise the board state according to the objective.
      */
@@ -79,7 +94,7 @@
     /**
      * Add a new tile placement to the board state, updating relevant
      * data structures accordingly.
-     *
+     * <p>
      * Note: this method is only used when initialising the board since the
      * tiles are never removed from the board.
      *
@@ -104,6 +119,7 @@
 
     /**
      * This method may be useful for debugging.
+     *
      * @return A String representation of the board state of the current TempleTrap instance
      */
     public String getBoardState() {
@@ -121,13 +137,13 @@
      * characters in the solution (note that a solution string is made
      * up of tile symbols, the letter 'p' (for peg) and direction
      * letters.
-     *
+     * <p>
      * The number returned will match the number recorded in the upper
      * right of each game objective.  For example, objective 1 has
      * the number 11 in the upper right, and a correct solution string
      * for problem 1 will return the number 11 if passed to this
      * function.
-     *
+     * <p>
      * You may find this useful for the final (advanced) part of the
      * assignment, where you have to solve the game.
      *
@@ -150,10 +166,10 @@
      * single peg step -- note that a peg step is from one valid
      * position to the next, so may contain multiple directions if it
      * goes over green areas).
-     *
+     * <p>
      * You may find this useful for the final (advanced) part of the
      * assignment, where you have to solve the game.
-     *
+     * <p>
      * This method works both for complete solutions and partial solutions.
      *
      * @param solution a solution string
@@ -167,16 +183,16 @@
      * Assuming that the movement is valid, update the tile data structure
      * with a new tile and update the location field of that tile. The previous
      * location of the tile in the tile data structure should be set to null.
-     *
+     * <p>
      * Each entry in the data structure corresponds to a location, and
      * each location contains either a tile or is null.
-     *
+     * <p>
      * locations that are covered by a tile will have their data structure
      * entry point to the covering tile.
-     *
+     * <p>
      * locations that are not covered by a tile will point to null.
      *
-     * @param tile  The Tile to be moved.
+     * @param tile      The Tile to be moved.
      * @param direction The direction in which to move the tile.
      */
     public void moveTile(Tile tile, Direction direction) {
@@ -189,6 +205,7 @@
 
     /**
      * Update the peg's position in the current game.
+     *
      * @param next the position the peg should be located in after running this method.
      */
     public void updatePeg(int next) {
@@ -211,8 +228,39 @@
      * @return true if the boardState is valid, false if it is invalid.
      */
     public static boolean isBoardStateValid(String boardState) {
-        return false;  // FIXME Task 4 (P)
+        if (boardState.length() != 17) {
+            return false;
+        }
+        int[] ans = new int[9];
+        Set<Integer> set = new HashSet<>();
+        for (int i = 0; i < 8; ++i) {
+            if (!Character.isDigit(boardState.charAt(2 * i + 1)) || Integer.parseInt(String.valueOf(boardState.charAt(2 * i + 1))) == 9 || Integer.parseInt(String.valueOf(boardState.charAt(16))) == 9) {
+                return false;
+            } else {
+                ans[i] = Integer.parseInt(String.valueOf(boardState.charAt(2 * i + 1)));
+                set.add(ans[i]);
+            }
+        }
+        if (set.size() != 8) {
+            return false;
+        }
+        set.add(Integer.parseInt(String.valueOf(boardState.charAt(16))));
+        if (set.size() != 8) {
+            return false;
+        }
+        for (int i = 0; i < 8; ++i) {
+            if (boardState.charAt(2 * i) != 'N' && boardState.charAt(2 * i) != 'E' && boardState.charAt(2 * i) != 'S' && boardState.charAt(2 * i) != 'W') {
+                return false;
+            }
+        }
+        for (int i = 0; i < 3; ++i) {
+            if (Integer.parseInt(String.valueOf(boardState.charAt(16))) == Integer.parseInt(String.valueOf(boardState.charAt(2 * i + 1)))) {
+                return false;
+            }
+        }
+        return true;
     }
+    //  FIXME Task 4 (P)
 
     /**
      * Given a position and a direction to move in, determine the next position.
@@ -223,13 +271,45 @@
      * finish position, or OFF_BOARD if it is off the board.
      */
     public static int getNextPosition(int pos, Direction dir) {
-        return -3; // FIXME Task 6 (P)
+        if (pos == 0 && dir.toString().equals("W")) {
+            return FINISH_POSITION;
+        }
+        switch (dir.toString()) {
+            case ("S"):
+                if (pos + 3 <= 8) {
+                    return pos + 3;
+                } else {
+                    return OFF_BOARD;
+                }
+            case ("N"):
+                if (pos - 3 > 0) {
+                    return pos - 3;
+                } else if (pos - 3 == 0) {
+                    return FINISH_POSITION;
+                } else {
+                    return OFF_BOARD;
+                }
+            case ("W"):
+                if (pos % 3 >= 1) {
+                    return pos - 1;
+                } else if (pos - 1 == 0) {
+                    return FINISH_POSITION;
+                } else {
+                    return OFF_BOARD;
+                }
+            default:
+                if (pos % 3 <= 1) {
+                    return pos + 1;
+                } else {
+                    return OFF_BOARD;
+                }
+        }// FIXME Task 6 (P)
     }
 
 
     /**
      * Determine whether a given tile can be moved.
-     *
+     * <p>
      * A tile can only be moved if the following conditions are met:
      * - The Tile does not contain the Peg.
      * - The Tile is adjacent to an empty (null) space.
@@ -238,8 +318,36 @@
      * @return true if the tile can be moved, false otherwise
      */
     public boolean canMoveTile(Tile tile) {
-        return false;  // FIXME Task 8 (CR)
+        if (pegPosition == tile.position) {
+            return false;
+        }
+        String inistate = objective.getInitialState();
+        if (!isBoardStateValid(inistate)) {
+            return false;
+        }
+        int[] ans = new int[8];
+        Set<Integer> set1 = new HashSet<>();
+        for (int i = 0; i < 8; ++i) {
+            ans[i] = Integer.parseInt(String.valueOf(inistate.charAt(2 * i + 1)));
+            set1.add(ans[i]);
+        }
+        int nullposition = 10;
+        for (int i = 0; i < 9; ++i) {
+            if (!set1.contains(i)) {
+                nullposition = i;
+            }
+        }
+        if (nullposition - tile.position == 1 && nullposition % 3 >= 1) {
+            return true;
+        } else if (Math.abs(nullposition - tile.position) == 3) {
+            return true;
+        } else if (tile.position - nullposition == 1 && nullposition % 3 <= 1) {
+            return true;
+        } else {
+            return false;
+        }
     }
+    // FIXME Task 8 (CR)
 
     /**
      * Determine whether a Tile movement is valid.
@@ -248,12 +356,33 @@
      * - The Tile moves into an empty (null) space.
      * - The Tile being moved does not contain the Peg.
      *
-     * @param tile The Tile to be moved.
+     * @param tile      The Tile to be moved.
      * @param direction the direction the tile is to be moved in.
      * @return true if the movement is valid, false if it is invalid.
      */
     public boolean isTileMovementValid(Tile tile, Direction direction) {
-        return false;  // FIXME Task 9 (CR)
+        if (!canMoveTile(tile)) {
+            return false;
+        }
+        String inistate = objective.getInitialState();
+        int[] ans = new int[8];
+        Set<Integer> set1 = new HashSet<>();
+        for (int i = 0; i < 8; ++i) {
+            ans[i] = Integer.parseInt(String.valueOf(inistate.charAt(2 * i + 1)));
+            set1.add(ans[i]);
+        }
+        int nullposition = 10;
+        for (int i = 0; i < 9; ++i) {
+            if (!set1.contains(i)) {
+                nullposition = i;
+            }
+        }
+        if (getNextPosition(tile.position, direction) != nullposition) {
+            return false;
+        } else {
+            return true;
+        }
+        // FIXME Task 9 (CR)
     }
 
     /**
@@ -261,18 +390,18 @@
      * first valid stopping position from a specified exit.  The finishing point is considered
      * a valid stopping position.   The method starts the path by exiting the starting tile via
      * exit A if viaA is true, otherwise exiting via exit B.
-     *
+     * <p>
      * Note that this is a search problem, so the implementation of this method is most
      * likely recursive, which means that getPegPathToDestination() (where the destination is the
      * finish position) is probably best solved by calling
      * getPegPathStep() on viable neighbours.
-     *
+     * <p>
      * The format of the path is a series of direction characters 'N', 'E', 'S', 'W' followed
      * by a character representing the finishing position (either "F" to indicate the finish
      * was reached, or single digit (eg '0') representing position).  The direction characters
      * reflect the path to the next step (ie the path to the first tile on which the peg
      * may stop, including the finish).
-     *
+     * <p>
      * If there is no path to a valid position from this tile using the specified exit, return null.
      *
      * @param start The starting position for the traversal.
@@ -281,8 +410,79 @@
      * directions and the endpoint), or null if there is no such path.
      */
     public String getPegPathStep(Tile start, boolean viaA) {
-        return null;  // FIXME Task 11 (D)
-    }
+        String inistate = objective.getInitialState();
+        int nextID = -10;
+        if (viaA) {
+            if ((start.position == FINISH_POSITION || start.position == 0) && start.exitAFaces() == Direction.WEST && !start.getTileType().name().equals("BROWN_CORNER")) {
+                return "WF";
+            }
+            int nexpos = getNextPosition(start.position, start.exitAFaces());
+            if (nexpos == OFF_BOARD) {
+                return null;
+            }
+            if (nexpos == FINISH_POSITION) {
+                nexpos = 0;
+            }
+            for (int i = 0; i < 8; ++i) {
+                if (Integer.parseInt(String.valueOf(inistate.charAt(2 * i + 1))) == nexpos) {
+                    nextID = i;
+                }
+            }
+            if (nextID == -10) {
+                return null;
+            }
+            Tile nexttile = Tile.getTileFromID(nextID);
+            if (nexttile.exitAFaces() == start.exitAFaces().getOpposite()) {
+                viaA = false;
+            }
+            if (!start.canTransit(nexttile)) {
+                return null;
+            } else if (start.canTransit(nexttile) && (nexttile.getTileType().name().equals("STAIRCASE") || nexttile.getTileType().name().equals("BROWN_CORNER"))) {
+                return start.exitAFaces().toString() + nexpos;
+            } else if (start.canTransit(nexttile) && (nexttile.getTileType().name().equals("STRAIGHT") || nexttile.getTileType().name().equals("GREEN_CORNER"))) {
+                if (getPegPathStep(nexttile, viaA) != null) {
+                    return start.exitAFaces().toString() + getPegPathStep(nexttile, viaA);
+                } else {
+                    return null;
+                }
+            }
+        } else {
+            if ((start.position == FINISH_POSITION || start.position == 0) && start.exitBFaces() == Direction.WEST && !start.getTileType().name().equals("BROWN_CORNER")) {
+                return "WF";
+            }
+            int nexpos = getNextPosition(start.position, start.exitBFaces());
+            if (nexpos == OFF_BOARD) {
+                return null;
+            }
+            if (nexpos == FINISH_POSITION) {
+                nexpos = 0;
+            }
+            for (int i = 0; i < 8; ++i) {
+                if (Integer.parseInt(String.valueOf(inistate.charAt(2 * i + 1))) == nexpos) {
+                    nextID = i;
+                }
+            }
+            if (nextID == -10) {
+                return null;
+            }
+            Tile nexttile = Tile.getTileFromID(nextID);
+            if (nexttile.exitAFaces() != start.exitBFaces().getOpposite()) {
+                viaA = true;
+            }
+            if (!start.canTransit(nexttile)) {
+                return null;
+            } else if (start.canTransit(nexttile) && (nexttile.getTileType().name().equals("STAIRCASE") || nexttile.getTileType().name().equals("BROWN_CORNER"))) {
+                return start.exitBFaces().toString() + nexpos;
+            } else if (start.canTransit(nexttile) && (nexttile.getTileType().name().equals("STRAIGHT") || nexttile.getTileType().name().equals("GREEN_CORNER"))) {
+                if (getPegPathStep(nexttile, viaA) != null) {
+                    return start.exitBFaces().toString() + getPegPathStep(nexttile, viaA);
+                } else {
+                    return null;
+                }
+            }
+        }
+        return null;
+    }// FIXME Task 11 (D)
 
     /**
      * Return a path for one step of the peg from its current position.
@@ -297,27 +497,78 @@
 
     /**
      * Return the path to the finish position if one exists.
-     *
+     * <p>
      * Starting at position start, exit via exit A if viaA is true, otherwise
      * via exit B, and keep moving the peg for more steps as long as there is a valid way forward.
-     * If there is a path for the peg that goes all the way to the
+     * If there is a path for the peg that goes all the way to
      * finish position, then return a string representing that path.  The
      * string should contain a series of direction characters 'N', 'E', 'S', 'W',
      * or should be null if there is no path to the finish.
      *
      * @param start The tile from which to start
-     * @param dest The destination tile as a character '0' ... '8', or 'F' for the finish point.
-     * @param viaA If true, start the search from exit A of the start tiles, otherwise use exit B.
+     * @param dest  The destination tile as a character '0' ... '8', or 'F' for the finish point.
+     * @param viaA  If true, start the search from exit A of the start tiles, otherwise use exit B.
      * @return A string representing the series of directions taken to reach the
      * finish position, or null if there is no path.
      */
     public String getPegPathToDestination(Tile start, char dest, boolean viaA) {
-        return null;  // FIXME Task 12 (HD)
+        String prepath = getPegPathStep(start, viaA);
+        if (prepath == null) {
+            return null;
+        }
+        if (viaA) {
+            String ans = "";
+            while (getPegPathStep(start, viaA) != null) {
+                String newpath = getPegPathStep(start, viaA);
+                ans = ans + newpath.substring(0, newpath.length() - 1);
+                if (newpath.charAt(newpath.length() - 1) == dest) {
+                    return ans;
+                }
+                if (newpath.charAt(newpath.length() - 1) != 'F') {
+                    int newpos = Integer.parseInt(String.valueOf(newpath.charAt(newpath.length() - 1)));
+                    Tile newtile = board[newpos];
+                    String dir = newpath.substring(newpath.length() - 2, newpath.length() - 1);
+                    if (newtile.exitAFaces().getOpposite().toString().equals(dir)) {
+                        viaA = false;
+                    } else {
+                        viaA = true;
+                    }
+                    start = newtile;
+                } else {
+                    break;
+                }
+            }
+            return null;
+        } else {
+            String ans = "";
+            while (getPegPathStep(start, viaA) != null) {
+                String newpath = getPegPathStep(start, viaA);
+                ans = ans + newpath.substring(0, newpath.length() - 1);
+                if (newpath.charAt(newpath.length() - 1) == dest) {
+                    return ans;
+                }
+                if (newpath.charAt(newpath.length() - 1) != 'F') {
+                    int newpos = Integer.parseInt(String.valueOf(newpath.charAt(newpath.length() - 1)));
+                    Tile newtile = board[newpos];
+                    String dir = newpath.substring(newpath.length() - 2, newpath.length() - 1);
+                    if (newtile.exitBFaces().getOpposite().toString().equals(dir)) {
+                        viaA = true;
+                    } else {
+                        viaA = false;
+                    }
+                    start = newtile;
+                } else {
+                    break;
+                }
+            }
+            return null;
+        }
     }
+    // FIXME Task 12 (HD)
 
     /**
      * Find the solutions to the game (the current TempleTrap object).
-     *
+     * <p>
      * Notice that this question is an advanced question and is entirely
      * optional.   You will need to use advanced data types and will
      * need to understand how to perform a search, most likely using
diff -ru -x .git /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java comp1110-ass1/src/comp1110/ass1/Tile.java
--- /Users/rachelschroder/Documents/Work/ANU_tutoring/COMP1110/comp1110-tutors/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java	2020-08-18 19:17:24.000000000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Tile.java	2020-08-18 19:35:48.000000000 +1000
@@ -1,5 +1,7 @@
 package comp1110.ass1;
 
+import java.lang.invoke.SwitchPoint;
+
 /**
  * This class represents a movable tile in the TempleTrap game.   The
  * class encodes which sort of tile it is (tileName), its orientation,
@@ -52,8 +54,8 @@
      * @return An int corresponding to the tile's position on the board.
      */
     public static int placementToPosition(String placement) {
-        return 0;  // FIXME Task 1 (P)
-    }
+        return Integer.parseInt(placement.substring(1,2));
+    }// FIXME Task 1 (P)
 
     /**
      * Given a two-character tile placement string, decode the tile's orientation.
@@ -64,8 +66,9 @@
      * @return A value of type `Direction` corresponding to the tile's orientation on board
      */
     public static Direction placementToOrientation(String placement) {
-       return null;  // FIXME Task 2.c (P)
+        return Direction.fromChar(placement.charAt(0));
     }
+    // FIXME Task 2.c (P)
 
     /**
      * Determine whether a given tile is adjacent to this tile instance,
@@ -80,8 +83,12 @@
      * they are not adjacent.
      */
     public Direction adjacencyDirection(Tile other) {
-        return null;  // FIXME Task 7 (CR)
-    }
+        if(other.position - 1 == this.position && other.position % 3 >=1) {return Direction.EAST;}
+        else if(other.position + 1 == this.position && other.position % 3 <= 1) {return Direction.WEST;}
+        else if(other.position - 3 == this.position) {return Direction.SOUTH;}
+        else if(other.position + 3 == this.position) {return Direction.NORTH;}
+        else{return null;}
+    }// FIXME Task 7 (CR)
 
     /**
      * Determine whether a peg can move between this tile and another (other).
@@ -100,8 +107,38 @@
      * @return true if a peg can legally transit from this tile to the other.
      */
     public boolean canTransit(Tile other) {
-        return false;  // FIXME Task 10 (D)
-    }
+        if (adjacencyDirection(other) == null) {return false;}
+        Direction dir = adjacencyDirection(other);
+        Direction otherdirA = other.getTileType().exitAFaces(other.orientation);
+        Direction otherdirB = other.getTileType().exitBFaces(other.orientation);
+        Direction thisdirA = this.getTileType().exitAFaces(this.orientation);
+        Direction thisdirB = this.getTileType().exitBFaces(this.orientation);
+        String thisType = this.getTileType().name();
+        String otherType = other.getTileType().name();
+        if (otherdirA != dir.getOpposite() && otherdirB != dir.getOpposite()){return false;}
+        if (otherType.equals("STAIRCASE") && thisType.equals("STAIRCASE") &&
+                (otherdirA == thisdirA.getOpposite() || otherdirB == thisdirB.getOpposite()))
+        {return true;}
+        if (((otherType.equals("STAIRCASE") && thisType.equals("GREEN_CORNER")) || (otherType.equals("STAIRCASE") && thisType.equals("STRAIGHT"))) &&
+                (otherdirA == thisdirA.getOpposite() || otherdirA == thisdirB.getOpposite()))
+        {return true;}
+        if ((otherType.equals("STAIRCASE") && thisType.equals("BROWN_CORNER")) &&
+                (otherdirB == thisdirA.getOpposite() || otherdirB == thisdirB.getOpposite()))
+        {return true;}
+        if (((otherType.equals("GREEN_CORNER") && thisType.equals("STAIRCASE")) || (otherType.equals("STRAIGHT") && thisType.equals("STAIRCASE"))) &&
+                (otherdirA == thisdirA.getOpposite() || otherdirB == thisdirA.getOpposite()))
+        {return true;}
+        if (((otherType.equals("GREEN_CORNER") || otherType.equals("STRAIGHT")) && (thisType.equals("GREEN_CORNER") || thisType.equals("STRAIGHT"))) &&
+                (otherdirA == thisdirA.getOpposite() || otherdirB == thisdirA.getOpposite() || otherdirA == thisdirB.getOpposite() || otherdirB == thisdirB.getOpposite()))
+        {return true;}
+        if ((otherType.equals("BROWN_CORNER") && thisType.equals("BROWN_CORNER")) &&
+                (otherdirA == thisdirA.getOpposite() || otherdirB == thisdirA.getOpposite() || otherdirA == thisdirB.getOpposite() || otherdirB == thisdirB.getOpposite()))
+        {return true;}
+        if ((otherType.equals("BROWN_CORNER") && thisType.equals("STAIRCASE")) &&
+                (otherdirA == thisdirB.getOpposite() || otherdirB == thisdirB.getOpposite()))
+        {return true;}
+        return false;
+    }      // FIXME Task 10 (D)
 
     /** @return the orientation of this tile */
     public Direction getOrientation() { return orientation; }
```
